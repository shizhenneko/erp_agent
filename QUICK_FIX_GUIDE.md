# 泛化能力快速修复指南

## 已完成的改进 ✅

### 1. 修正了examples.txt中的时间示例
- ✅ 示例8改为使用相对时间（"去年到今年"）
- ✅ 添加了元认知警告，强调不要复制具体年份
- ✅ 增加了推理检查清单

### 2. 加强了system_prompt.txt
- ✅ 增强了时间计算规则的说明
- ✅ 添加了Thought字段的详细要求
- ✅ 强调了独立思考的重要性

## 下一步建议（优先级排序）

### 🔴 高优先级（立即执行）

#### 1. 测试改进效果
```bash
# 运行泛化能力测试
python test_generalization.py

# 或者重新运行问题9
python erp_agent/main.py --question "从去年到今年涨薪幅度最大的10位员工是谁？"
```

#### 2. 抽象化更多时间相关示例
需要检查和修改的示例：
- [ ] 示例2: "去年第三季度" - 已经是相对时间，需要加强说明
- [ ] 检查其他示例是否有具体年份

**执行方法：**
```bash
# 搜索所有具体年份
grep -n "202[0-9]" erp_agent/prompts/examples.txt
```

#### 3. 精简示例数量（可选但推荐）
当前10个示例 → 建议保留6个核心示例

**保留建议：**
1. 示例1: 基础查询
2. 示例2: 时间推理（已优化）
3. 示例3: 多表JOIN
4. 示例8: 跨期对比（已优化）
5. 示例9: 数据完整性检测
6. 一个复杂聚合示例

**删除/合并建议：**
- 过于简单的示例（功能重复）
- 可以通过system prompt说明的基础概念

---

### 🟡 中优先级（本周完成）

#### 4. 增强结果验证机制

在`erp_agent/core/result_analyzer.py`中添加：

```python
def validate_time_reasoning(self, sql: str, current_year: int) -> Dict:
    """验证SQL中的时间推理是否正确"""
    # 提取SQL中的年份
    years = re.findall(r'\b(20\d{2})\b', sql)
    
    # 检查是否使用了合理的年份范围
    valid_range = range(current_year - 5, current_year + 1)
    invalid_years = [y for y in map(int, years) if int(y) not in valid_range]
    
    if invalid_years:
        return {
            'valid': False,
            'warning': f"SQL中使用了不合理的年份: {invalid_years}",
            'suggestion': f"当前是{current_year}年，请检查时间计算是否正确"
        }
    
    return {'valid': True}
```

#### 5. 创建测试基准
```bash
# 创建标准测试集
python -c "
test_questions = [
    '从去年到今年的涨薪幅度',
    '前年第二季度的业绩',
    '最近三个月的数据',
    # ... 更多
]
# 保存为baseline
"
```

---

### 🟢 低优先级（长期优化）

#### 6. 实施负样本学习
在examples.txt中添加"错误示例"部分

#### 7. 评估模型升级
如果上述改进后效果仍不理想，考虑：
- Claude 3.5 Sonnet
- GPT-4 Turbo
- 或其他更强的模型

---

## 如何判断改进是否有效？

### 核心指标

1. **时间准确率**
   - 问题9应该使用2025-2026年（而非2024-2025）
   - 目标：100%正确

2. **Thought质量**
   - 是否明确展示时间计算
   - 是否引用Schema
   - 目标：每个查询都有完整推理链

3. **泛化测试通过率**
   - 运行`test_generalization.py`
   - 目标：>80%通过率

### 快速验证脚本

```bash
#!/bin/bash
# quick_test.sh

echo "测试1: 时间推理"
python erp_agent/main.py --question "从去年到今年涨薪幅度最大的10位员工是谁？" | grep -E "2025|2026"

echo "测试2: Schema使用"
python erp_agent/main.py --question "每个部门的平均工资" | grep -E "employees|departments"

echo "测试3: 思维链质量"
python erp_agent/main.py --question "去年平均工资" --verbose | grep "当前年份"
```

---

## 理论基础：为什么会出现这个问题？

### 问题本质
这不是"模型不会推理"，而是：

```
信息冲突场景：
┌─────────────────────────────────┐
│ System Prompt: "去年=2025年"    │ ← 抽象规则
│         VS                      │
│ Example 8: "使用2024-2025年"    │ ← 具体示例
└─────────────────────────────────┘
         ↓
   模型优先选择具体示例
   （因为模式匹配更快）
```

### 为什么具体示例影响更大？

1. **认知捷径（Heuristic）**
   - 大脑（和LLM）倾向于使用"快速模式匹配"
   - 具体案例提供了现成的模板
   - 抽象规则需要额外推理

2. **Few-shot Learning机制**
   - 示例越具体，记忆越深
   - 类似问题会触发示例检索
   - "锚定效应"导致直接复制

3. **Token注意力分配**
   - 示例通常更长、更详细
   - 在attention机制中权重更高
   - System prompt虽然重要但较抽象

### 解决原理

```
策略1: 抽象化示例
┌─────────────────────────────────┐
│ Example: "使用{year-1}和{year}" │ ← 破坏直接模式匹配
└─────────────────────────────────┘
         ↓
   强制模型每次重新计算

策略2: 精简示例
┌─────────────────────────────────┐
│ 6个核心示例 (vs 10个)           │ ← 减少"过拟合"
└─────────────────────────────────┘
         ↓
   提高泛化能力

策略3: 增强元认知
┌─────────────────────────────────┐
│ "不要复制示例中的年份！"        │ ← 激活"监控系统"
└─────────────────────────────────┘
         ↓
   提高自我纠错能力
```

---

## 常见问题

### Q1: 改进后还是不行怎么办？
A: 按优先级尝试：
1. 检查system_prompt是否正确传递给LLM
2. 增加更多元认知提示
3. 减少示例数量（从10个减到5个）
4. 升级到更强的模型

### Q2: 要不要完全删除示例？
A: 不建议。Few-shot learning仍然有效，关键是：
- 示例要抽象化（教方法）
- 不是具体化（给答案）

### Q3: 如何平衡"教学"和"泛化"？
A: 金字塔原则：
```
System Prompt（顶层）: 原则和规则
     ↓
Examples（中层）: 方法和模式
     ↓
Schema（底层）: 具体数据结构
```

每一层都要抽象，但越往下越具体。

---

## 总结

### 已做的事（5分钟完成）✅
1. 修正示例8的年份
2. 加强system prompt
3. 添加元认知警告
4. 创建测试脚本

### 还要做的事（1-2小时）
1. 运行测试验证效果
2. 抽象化其他时间相关内容
3. 考虑精简示例数量

### 预期效果
- 短期：修复问题9的时间推理错误
- 中期：提升20-30%泛化能力
- 长期：建立稳健的推理框架

---

**立即行动**：
```bash
# 1. 测试当前效果
python test_generalization.py

# 2. 重新测试问题9
python -m erp_agent.tests.test_questions --question 9

# 3. 查看完整改进方案
cat GENERALIZATION_IMPROVEMENT_PLAN.md
```
