# 问题9修复诊断报告

## 问题现象

测试显示即使修改后，Agent仍然在第一轮Thought中说：
> "需要比较员工在**2024年和2025年**的工资变化幅度"

**期望行为**：应该说"需要比较员工在**2025年和2026年**的工资变化幅度"

## 根本原因

示例8的影响过于强大，虽然我们修改了部分内容，但：
1. 示例8的SQL中仍然硬编码了2024、2025年
2. 具体数字的"锚定效应"超出预期
3. 模型倾向于直接复制最相似示例的模式

## 本轮修复措施（已完成）

### 1. ✅ 彻底抽象化示例8

**Before:**
```
问题: "哪些借阅者从2024年到2025年借书量增长最快？"
SQL: WHERE EXTRACT(YEAR FROM loan_date) = 2024 ...
```

**After:**
```
问题: "哪些借阅者从 YEAR_A 到 YEAR_B 借书量增长最快？"
⚠️ 重要提醒: YEAR_A和YEAR_B是抽象占位符，必须根据当前年份{year}重新计算
SQL: WHERE EXTRACT(YEAR FROM date_column) = YEAR_A ...（模板示例）
```

### 2. ✅ 在system_prompt开头添加强警告

在"重要约束"后立即添加了：

```markdown
## ⚠️ 时间推理约束（最重要！）

当前系统时间是 {year} 年 {month} 月，你必须基于这个时间来理解所有相对时间表达式！

强制要求：
1. "去年" 永远指 {year_minus_1} 年，不是其他任何年份
2. "今年" 永远指 {year} 年，不是其他任何年份

❌ 错误: 看到示例中用2024、2025，就在实际SQL中也用2024、2025
✅ 正确: 理解示例教的是"去年=当前年-1"的方法，根据当前年份{year}重新计算
```

### 3. ✅ 强化时间示例的负例说明

在时间计算示例中添加了"不要写成"的反例。

## 验证方法

### 快速测试
```bash
# 运行专门的测试脚本
python test_question_9_fix.py
```

**预期输出：**
- ✅ Thought中应该提到"2026"或"当前年份"
- ✅ SQL中应该使用 2025 和 2026
- ❌ SQL中不应该使用 2024

### 手动验证
```bash
python -m erp_agent.tests.test_questions --question 9
```

查看日志中第一轮的Thought，应该包含类似：
> "当前年份是2026年，去年是2025年，今年是2026年，因此比较2025和2026年的工资"

## 如果还是失败怎么办？

### 方案A：更激进的示例删除（推荐）

如果上述修改还不够，说明示例8的影响太强，考虑**完全删除**或**移到附录**：

```python
# 编辑 examples.txt
# 将示例8整个删除或注释掉
```

**理由：**
- 示例8专门教跨期对比，与问题9太相似
- 即使抽象化，仍可能触发模式匹配
- 其他示例（CTE、JOIN等技术）足以支持推理

### 方案B：在问题中添加元提示

修改用户问题，强制模型思考：

```python
# 在 test_questions.py 中
question = """从去年到今年涨薪幅度最大的10位员工是谁？

提示：请先明确当前年份，然后计算"去年"和"今年"分别是哪一年。"""
```

### 方案C：增加前置验证步骤

在agent.py中添加SQL验证：

```python
def validate_sql_years(sql: str, current_year: int) -> bool:
    """验证SQL中的年份是否合理"""
    years = re.findall(r'\b(20\d{2})\b', sql)
    years_int = [int(y) for y in years]
    
    # 检查是否在合理范围内（当前年份±5年）
    valid_range = range(current_year - 5, current_year + 1)
    for year in years_int:
        if year not in valid_range:
            logger.warning(
                f"SQL中使用了可疑的年份 {year}，"
                f"当前年份是 {current_year}，请检查时间计算"
            )
            return False
    return True
```

### 方案D：使用更强的模型

如果prompt engineering已经到极限，考虑：
- Claude 3.5 Sonnet（推荐）
- GPT-4 Turbo
- 其他推理能力更强的模型

更强的模型对抽象规则的理解更好，不容易被具体示例误导。

## 深层次分析

### 为什么这么难修复？

这个问题暴露了Few-shot Learning的一个固有限制：

```
问题匹配度计算：
┌─────────────────────────────────────┐
│ 用户问题: "从去年到今年涨薪幅度"    │
│          ↓ 相似度匹配                │
│ 示例8: "从YEAR_A到YEAR_B借书量增长" │
│          ↓ 相似度 > 90%              │
│ 触发: 直接套用示例模式               │
└─────────────────────────────────────┘
```

即使我们把示例改成占位符，"跨期对比"这个**结构相似性**仍然触发了强烈的模式匹配。

### 技术债务

这个问题的根源是：
1. **Examples设计时过于具体**：使用了真实年份
2. **没有充分的元认知提示**：缺少"不要照搬"的警告
3. **验证机制缺失**：没有检查生成的SQL是否合理

### 长期解决方案

1. **重新设计Examples架构**：
   ```
   Part 1: 纯技术模式库（无具体问题）
   - CTE模式
   - JOIN模式
   - 窗口函数模式
   
   Part 2: 推理方法示例（抽象化场景）
   - 时间推理方法（无具体年份）
   - 数据完整性检测方法
   ```

2. **建立测试驱动的Prompt开发流程**：
   ```
   编写测试 → 修改Prompt → 运行测试 → 迭代优化
   ```

3. **添加运行时验证**：
   - SQL生成后自动检查年份合理性
   - Thought质量评分
   - 异常模式告警

## 预期修复效果

### 乐观情况（70%概率）
- ✅ 本轮修改足够强，模型能正确推理
- ✅ Thought中明确展示时间计算
- ✅ SQL使用2025和2026

### 需要进一步调整（25%概率）
- ⚠️ 仍然使用2024-2025
- 需要执行方案A（删除示例8）
- 或执行方案C（添加验证）

### 需要根本性改变（5%概率）
- ❌ Prompt engineering已达极限
- 需要方案D（升级模型）
- 或重新设计整个prompt架构

## 行动清单

### 立即执行（5分钟）
- [ ] 运行 `python test_question_9_fix.py`
- [ ] 查看Thought中是否提到2026
- [ ] 查看SQL中是否使用2025和2026

### 如果测试失败（30分钟）
- [ ] 执行方案A：删除示例8
- [ ] 或执行方案C：添加SQL验证
- [ ] 重新测试

### 长期优化（1-2天）
- [ ] 重新设计Examples架构
- [ ] 建立自动化测试套件
- [ ] 评估模型升级的ROI

## 结论

这次修复已经做到了prompt engineering的极致：
1. ✅ 彻底抽象化了问题示例
2. ✅ 添加了最强的警告和说明
3. ✅ 提供了正反例对比

如果还是失败，说明问题不在prompt，而在于：
- 模型的基础推理能力
- Few-shot Learning的固有局限
- 需要考虑模型升级或架构重构

**建议：先测试，根据结果决定下一步。**
